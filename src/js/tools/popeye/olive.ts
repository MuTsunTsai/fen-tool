import { parseAllDocuments } from "yaml";

import { makeEntry } from "../project/entry";
import { emptyBoard, makeForsyth, parseSquare } from "js/meta/fen";
import { INIT_SQ_COUNT } from "js/meta/constants";
import { Color } from "js/meta/enum";
import { findCustom } from "js/meta/popeye/base";
import { alert } from "js/meta/dialogs";

import type { ProjectEntry } from "../project/entry";

interface OliveFormat {
	algebraic: {
		black?: string[];
		white?: string[];
		neutral?: string[];
	};
	options?: string[];
	stipulation?: string;
}

export function parseOliveFormat(content: string): ProjectEntry[] | null {
	try {
		content = content.replace(/!!python\/unicode /g, ""); // generated by pyyaml
		const documents = parseAllDocuments(content);
		const entries: ProjectEntry[] = [];
		for(const [i, document] of documents.entries()) {
			const json = document.toJS() as OliveFormat;
			const popeye: string[] = [];
			const board = emptyBoard(INIT_SQ_COUNT);
			try {
				if(json.algebraic.black) insertPieces(board, json.algebraic.black, Color.black);
				if(json.algebraic.white) insertPieces(board, json.algebraic.white, Color.white);
				if(json.algebraic.neutral) insertPieces(board, json.algebraic.neutral, Color.neutral);
			} catch(e) {
				if(e instanceof Error) {
					alert("The following fairy piece cannot be mapped: " + e.message +
						"\nPlease edit the fairy piece mapping to include it.");
				}
				break;
			}
			if(json.stipulation) popeye.push("Stipulation " + json.stipulation);
			const { options, conditions } = parseOptionCondition(json.options);
			popeye.push("Option " + options.join(" "));
			if(conditions.length) popeye.push("Condition " + conditions.join(" "));

			const fen = makeForsyth(board);
			entries.push(makeEntry(fen, popeye.join("\n"), i));
		}
		return entries;
	} catch(e) {
		console.log(e);
		return null;
	}
}

function parseOptionCondition(items?: string[]): { options: string[], conditions: string[] } {
	const options: string[] = ["Variation"];
	const conditions: string[] = [];
	if(items) {
		for(const item of items) {
			if(OptionRegExps.some(reg => reg.test(item))) options.push(item);
			else conditions.push(item);
		}
	}
	return { options, conditions };
}

// All Popeye options according to its docs
const OptionRegExps = [
	"Try",
	"Defence [1-9]\\d*",
	"SetPlay",
	"NullMoves",
	"Threat [1-9]\\d*",
	"WhiteToPlay",
	"Variation",
	"MoveNumbers",
	"StartMoveNumber [1-9]\\d*",
	"NoWk",
	"NoBk",
	"Duplex",
	"NoThreat",
	"MaxSolutions [1-9]\\d*",
	"MaxFlightsquares [1-9]\\d*",
	"EnPassant [a-h][36]( [a-h][36])?",
	"CastlingMutuallyExclusive [ah][18][ah][18]",
	"NoBoard",
	"NoShortVariations",
	"HalfDuplex",
	"PostKeyPlay",
	"NonTrivial [1-9]\\d* [1-9]\\d*",
	"Intelligent",
	"MaxTime [1-9]\\d*",
	"NoCastling( [aeh][18])+",
	"Quodlibet",
	"StopOnShortSolutions",
	"Beep",
	"SuppressGrid",
	"WriteGrid",
	"KeepMatingPiece",
	"LastCapture .+",
	"GoalIsEnd",
].map(s => new RegExp("^" + s + "$"));

function insertPieces(board: Board, items: string[], color: Color): void {
	for(const item of items) {
		const raw = item.substring(0, item.length - 2);
		let piece = findPiece(raw);
		if(!piece) throw new Error(raw);
		const sq = parseSquare(item.substring(item.length - 2));
		if(color == Color.white) piece = piece.toUpperCase();
		else if(color == Color.black) piece = piece.toLowerCase();
		else piece = "=" + piece;
		board[sq] = piece;
	}
}

function findPiece(piece: string): string | undefined {
	if(["K", "Q", "B", "R", "P"].includes(piece)) return piece;
	if(piece == "S") return "N";
	return findCustom(piece);
}
