import { parseAllDocuments } from "yaml";

import { makeEntry } from "../project/entry";
import { emptyBoard, makeForsyth, parseSquare } from "app/meta/fen";
import { INIT_SQ_COUNT } from "app/meta/constants";
import { Color } from "app/meta/enum";
import { toNormalFEN } from "app/meta/popeye/popeye";
import { FORSYTH } from "./popeye";
import { pieceCommand } from "app/meta/popeye/piece";

import type { PopeyeBoardInfo } from "./popeye";
import type { ProjectEntry } from "../project/entry";

interface Algebraic {
	black?: string[];
	white?: string[];
	neutral?: string[];
}

interface OliveFormat {
	algebraic: Algebraic;
	options?: string[];
	stipulation?: string;
}

export function parseOliveFormat(content: string): ProjectEntry[] | null {
	try {
		content = content.replace(/!!python\/unicode /g, ""); // generated by pyyaml
		const documents = parseAllDocuments(content);
		const entries: ProjectEntry[] = [];
		for(const [i, document] of documents.entries()) {
			const json = document.toJS() as OliveFormat;
			const fen = toPopeyeFen(json.algebraic);
			const popeye: string[] = [];
			if(fen !== toNormalFEN(fen)) popeye.push("Forsyth " + fen);
			if(json.stipulation) popeye.push("Stipulation " + json.stipulation);
			const { options, conditions } = parseOptionCondition(json.options);
			popeye.push("Option " + options.join(" "));
			if(conditions.length) popeye.push("Condition " + conditions.join(" "));
			entries.push(makeEntry({
				fen,
				popeye: popeye.join("\n"),
			}, i));
		}
		return entries;
	} catch(e) {
		console.log(e);
		return null;
	}
}

function parseOptionCondition(items?: string[]): { options: string[], conditions: string[] } {
	const options: string[] = ["Variation"];
	const conditions: string[] = [];
	if(items) {
		for(const item of items) {
			if(OptionRegExps.some(reg => reg.test(item))) options.push(item);
			else conditions.push(item);
		}
	}
	return { options, conditions };
}

// All Popeye options according to its docs
const OptionRegExps = [
	"Try",
	"Defence [1-9]\\d*",
	"SetPlay",
	"NullMoves",
	"Threat [1-9]\\d*",
	"WhiteToPlay",
	"Variation",
	"MoveNumbers",
	"StartMoveNumber [1-9]\\d*",
	"NoWk",
	"NoBk",
	"Duplex",
	"NoThreat",
	"MaxSolutions [1-9]\\d*",
	"MaxFlightsquares [1-9]\\d*",
	"EnPassant [a-h][36]( [a-h][36])?",
	"CastlingMutuallyExclusive [ah][18][ah][18]",
	"NoBoard",
	"NoShortVariations",
	"HalfDuplex",
	"PostKeyPlay",
	"NonTrivial [1-9]\\d* [1-9]\\d*",
	"Intelligent",
	"MaxTime [1-9]\\d*",
	"NoCastling( [aeh][18])+",
	"Quodlibet",
	"StopOnShortSolutions",
	"Beep",
	"SuppressGrid",
	"WriteGrid",
	"KeepMatingPiece",
	"LastCapture .+",
	"GoalIsEnd",
].map(s => new RegExp("^" + s + "$"));

function insertPieces(board: Board, items: string[], color: Color): void {
	for(const item of items) {
		const sq = parseSquare(item.substring(item.length - 2));
		let piece = item.substring(0, item.length - 2); // uppercase by default
		if(piece.length == 2) piece = "." + piece;
		const isBlack = color == Color.black;
		if(isBlack) piece = piece.toLowerCase();
		if(color == Color.neutral) piece = "=" + piece;
		else if(!(/[a-z]/i).test(piece)) piece = (isBlack ? "-" : "+") + piece;
		board[sq] = piece;
	}
}

function toPopeyeFen(algebraic: Algebraic): string {
	const board = emptyBoard(INIT_SQ_COUNT);
	if(algebraic.black) insertPieces(board, algebraic.black, Color.black);
	if(algebraic.white) insertPieces(board, algebraic.white, Color.white);
	if(algebraic.neutral) insertPieces(board, algebraic.neutral, Color.neutral);
	return makeForsyth(board);
}

export function normalizeInput(input: string, info: PopeyeBoardInfo): string {
	if(info.fromInput) {
		input = input
			.replace(new RegExp(`${pieceCommand}\\s+`, "ig"), "")
			.replace(new RegExp(`${FORSYTH}\\s\\S+\\s+`, "ig"), "");
	}
	if(
		info.fen !== toNormalFEN(info.fen) &&
		!input.includes("Forsyth")
	) {
		input = `Forsyth ${info.fen}\n${input}`;
	}
	return input;
}
